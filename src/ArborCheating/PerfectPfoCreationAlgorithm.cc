  /// \file PerfectPfoCreationAlgorithm.cc
/*
 *
 * PerfectPfoCreationAlgorithm.cc source template automatically generated by a class generator
 * Creation date : sam. mars 21 2015
 *
 * This file is part of ArborContent libraries.
 *
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author John Marshall
 */

#include "Pandora/AlgorithmHeaders.h"
#include "Api/PandoraContentApi.h"

#include "ArborCheating/PerfectPfoCreationAlgorithm.h"
#include "ArborHelpers/ClusterHelper.h"
#include "ArborHelpers/CaloHitHelper.h"
#include "ArborHelpers/ReclusterHelper.h"

namespace arbor_content
{

PerfectPfoCreationAlgorithm::PerfectPfoCreationAlgorithm() :
    m_shouldCreateTrackBasedPfos(true),
    m_shouldCreateNeutralPfos(true),
    m_minClusterHadronicEnergy(0.1f),
    m_minClusterElectromagneticEnergy(0.1f),
    m_minHitsInCluster(5),
    m_allowSingleLayerClusters(false),
    m_photonPositionAlgorithm(2)
{
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PerfectPfoCreationAlgorithm::Run()
{
#if 0
	// delete all clusters ...
	{
        const pandora::ClusterList *pClusterList = NULL;
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

        if(pClusterList->empty())
          return pandora::STATUS_CODE_SUCCESS;

        pandora::ClusterVector clusterVector(pClusterList->begin(), pClusterList->end());

	    ////
        for(pandora::ClusterVector::const_iterator iter = clusterVector.begin(), endIter = clusterVector.end() ;
            endIter != iter ; ++iter)
        {
          pandora::CaloHitList caloHitList;
          (*iter)->GetOrderedCaloHitList().FillCaloHitList(caloHitList);

          PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::RemoveConnections(&caloHitList));
          PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Delete(*this, *iter));
        }
	}
#endif
	PandoraContentApi::RemoveAllTrackClusterAssociations(*this);

    const pandora::PfoList *pPfoList = NULL; std::string pfoListName;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::CreateTemporaryListAndSetCurrent(*this, pPfoList, pfoListName));

#if 0
    const pandora::ClusterList *pClusterList = NULL; std::string clusterListName;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::CreateTemporaryListAndSetCurrent(*this, pClusterList, clusterListName));
#endif

	//std::cout << "PerfectPfoCreationAlgorithm: pPfoList: " << pPfoList->size() << std::endl;

    if (m_shouldCreateTrackBasedPfos)
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->CreateTrackBasedPfos());

#if 0
    if (m_shouldCreateNeutralPfos)
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->CreateNeutralPfos());
#endif

#if 0
	std::string m_outputClusterListName("clusters_add");

    if (!pClusterList->empty())
    {
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::SaveList<pandora::Cluster>(*this, m_outputClusterListName));
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::ReplaceCurrentList<pandora::Cluster>(*this, m_outputClusterListName));
    }
#endif

    if (!pPfoList->empty())
    {
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::SaveList<pandora::Pfo>(*this, m_outputPfoListName));
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::ReplaceCurrentList<pandora::Pfo>(*this, m_outputPfoListName));
    }

    //PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pPfoList));
	//std::cout << "check the pPfoList: " << pPfoList->size() << std::endl;

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------
//
void PerfectPfoCreationAlgorithm::TrackCollection(const pandora::MCParticle *const pPfoTarget, PfoParameters &pfoParameters) const
{
    const pandora::TrackList *pTrackList = NULL;
    PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pTrackList));
	//std::cout << "---track size: " << pTrackList->size() << std::endl;

    for (pandora::TrackList::const_iterator iter = pTrackList->begin(), iterEnd = pTrackList->end(); iter != iterEnd; ++iter)
    {
        try
        {
            const pandora::Track *const pTrack = *iter;
            const pandora::MCParticle *const pTrkMCParticle(pandora::MCParticleHelper::GetMainMCParticle(pTrack));
            const pandora::MCParticle *const pTrkPfoTarget(pTrkMCParticle->GetPfoTarget());

            if (pTrkPfoTarget != pPfoTarget)
                continue;

            pfoParameters.m_trackList.push_back(pTrack);

			//std::cout << "found a track: " << pTrack << " for MCP: " << pTrkPfoTarget << std::endl;
        }
        catch (pandora::StatusCodeException &e)
        {
			//std::cout << e.ToString() << std::endl;
        }
    }
}

void PerfectPfoCreationAlgorithm::CaloHitCollection(const pandora::MCParticle *const pPfoTarget, PfoParameters &pfoParameters) const
{
#if 0
    const pandora::CaloHitList *pCaloHitList = NULL;
    PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pCaloHitList));

    const pandora::Cluster *pCluster = NULL;
    const pandora::CaloHitList localCaloHitList(pCaloHitList->begin(), pCaloHitList->end());

	std::cout << "---------- CaloHitCollection " << std::endl;

    for (pandora::CaloHitList::const_iterator iter = localCaloHitList.begin(), iterEnd = localCaloHitList.end(); iter != iterEnd; ++iter)
    {
        try
        {
            const pandora::CaloHit *const pCaloHit = *iter;

            if (!PandoraContentApi::IsAvailable(*this, pCaloHit))
                continue;

            PandoraContentApi::Cluster::Parameters parameters;
			pandora::CaloHitList &caloHitList(parameters.m_caloHitList);

            //    this->SimpleCaloHitCollection(pPfoTarget, pCaloHit, caloHitList);
            const pandora::MCParticle *const pHitMCParticle(pandora::MCParticleHelper::GetMainMCParticle(pCaloHit));
            const pandora::MCParticle *const pHitPfoTarget(pHitMCParticle->GetPfoTarget());

            //if (pHitPfoTarget != pPfoTarget)
            //    return;

            if (pHitPfoTarget == pPfoTarget) caloHitList.push_back(pCaloHit);

            if (caloHitList.empty())
                continue;

#if 1
            if (NULL == pCluster)
            {
				std::cout << " ----- create a cluster ..." << std::endl;
                PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Cluster::Create(*this, parameters, pCluster));
                pfoParameters.m_clusterList.push_back(pCluster);
				std::cout << "   ---> done. " << std::endl;
            }
            else
            {
                for (pandora:: CaloHitList::const_iterator hitIter = caloHitList.begin(), hitIterEnd = caloHitList.end(); hitIter != hitIterEnd; ++hitIter)
                    PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::AddToCluster(*this, pCluster, *hitIter));
            }
#endif
        }
        catch (pandora::StatusCodeException &e)
        {
			//std::cout << e.ToString() << std::endl;
        }
    }
#endif


	/////
    const pandora::ClusterList *pClusterList = NULL;
    PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

    for (pandora::ClusterList::const_iterator iter = pClusterList->begin(), iterEnd = pClusterList->end(); iter != iterEnd; ++iter)
    {
        try
        {
            const pandora::Cluster *const pCluster = *iter;
            const pandora::MCParticle *const pClusterMCParticle(pandora::MCParticleHelper::GetMainMCParticle(pCluster));
            const pandora::MCParticle *const pClusterPfoTarget(pClusterMCParticle->GetPfoTarget());

            if (pClusterPfoTarget != pPfoTarget)
                continue;

            pfoParameters.m_clusterList.push_back(pCluster);

			//std::cout << "found a cluster: " << pCluster << " for MCP: " << pClusterPfoTarget << std::endl;
        }
        catch (pandora::StatusCodeException &e)
        {
			std::cout << e.ToString() << std::endl;
        }
    }
}

void PerfectPfoCreationAlgorithm::SetPfoParametersFromTracks(const pandora::MCParticle *const pPfoTarget, int &nTracksUsed, PfoParameters &pfoParameters) const
{
    if (!pfoParameters.m_trackList.empty())
    {
        int charge(0);
        float energyWithPionMass(0.f), energyWithElectronMass(0.f);
		pandora::CartesianVector momentum(0.f, 0.f, 0.f);

        for (pandora::TrackList::const_iterator iter = pfoParameters.m_trackList.begin(), iterEnd = pfoParameters.m_trackList.end(); iter != iterEnd; ++iter)
        {
            const pandora::Track *const pTrack = *iter;

            if (!pTrack->CanFormPfo() && !pTrack->CanFormClusterlessPfo())
            {
                std::cout << pPfoTarget << " Drop track, E: " << pTrack->GetEnergyAtDca() << " cfp: " << pTrack->CanFormPfo() << " cfcp: " << pTrack->CanFormClusterlessPfo() << std::endl;
                continue;
            }

            if (!pTrack->GetParentList().empty())
            {
                std::cout << pPfoTarget << " Drop track, E: " << pTrack->GetEnergyAtDca() << " nParents: " << pTrack->GetParentList().size() << std::endl;
                continue;
            }

            ++nTracksUsed;

            // ATTN Assume neutral track-based pfos represent pair-production
            const float electronMass(pandora::PdgTable::GetParticleMass(pandora::E_MINUS));

            charge += pTrack->GetCharge();
            momentum += pTrack->GetMomentumAtDca();
            energyWithPionMass += pTrack->GetEnergyAtDca();
            energyWithElectronMass += std::sqrt(electronMass * electronMass + pTrack->GetMomentumAtDca().GetMagnitudeSquared());
        }

        if (0 == nTracksUsed)
            return;

        pfoParameters.m_charge = charge;
        pfoParameters.m_momentum = momentum;
        pfoParameters.m_particleId = (pfoParameters.m_charge.Get() == 0) ? pandora::PHOTON : (pfoParameters.m_charge.Get() < 0) ? pandora::PI_MINUS : pandora::PI_PLUS;
        pfoParameters.m_energy = (pfoParameters.m_particleId.Get() == pandora::PHOTON) ? energyWithElectronMass : energyWithPionMass;
        pfoParameters.m_mass = std::sqrt(std::max(pfoParameters.m_energy.Get() * pfoParameters.m_energy.Get() - pfoParameters.m_momentum.Get().GetDotProduct(pfoParameters.m_momentum.Get()), 0.f));
    }
}

/////////

void PerfectPfoCreationAlgorithm::SetPfoParametersFromClusters(const pandora::MCParticle *const pPfoTarget, const int nTracksUsed, PfoParameters &pfoParameters) const
{
    const pandora::Cluster *pCluster = NULL;

    if (!pfoParameters.m_clusterList.empty())
    {
        if (1 != pfoParameters.m_clusterList.size())
            throw pandora::StatusCodeException(pandora::STATUS_CODE_FAILURE);

        pCluster = *(pfoParameters.m_clusterList.begin());
    }

    if ((0 == nTracksUsed) && !pfoParameters.m_clusterList.empty())
    {
        const bool isPhoton(pandora::PHOTON == pPfoTarget->GetParticleId());

        const float clusterEnergy(isPhoton ? pCluster->GetCorrectedElectromagneticEnergy(this->GetPandora()) :
            pCluster->GetCorrectedHadronicEnergy(this->GetPandora()));
        const pandora::CartesianVector positionVector(!isPhoton ? pCluster->GetCentroid(pCluster->GetInnerPseudoLayer()) :
            this->GetEnergyWeightedCentroid(pCluster, pCluster->GetInnerPseudoLayer(), pCluster->GetOuterPseudoLayer()));

        pfoParameters.m_particleId = (isPhoton ? pandora::PHOTON : pandora::NEUTRON);
        pfoParameters.m_charge = 0;
        pfoParameters.m_mass = (isPhoton ? pandora::PdgTable::GetParticleMass(pandora::PHOTON) : pandora::PdgTable::GetParticleMass(pandora::NEUTRON));
        pfoParameters.m_energy = clusterEnergy;
        pfoParameters.m_momentum = positionVector.GetUnitVector() * clusterEnergy;
    }

    // Track-cluster associations hack
    if (NULL != pCluster)
    {
        for (pandora::TrackList::const_iterator iterTrk = pfoParameters.m_trackList.begin(), iterTrkEnd = pfoParameters.m_trackList.end(); iterTrk != iterTrkEnd; ++iterTrk)
            PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::AddTrackClusterAssociation(*this, *iterTrk, pCluster));
    }
}

pandora::StatusCode PerfectPfoCreationAlgorithm::CreateTrackBasedPfos() const
{
	//std::cout << "In  PerfectPfoCreationAlgorithm::CreateTrackBasedPfos() " << std::endl;

#if 0
    // Current track list should contain those tracks selected as "good" by the track preparation algorithm
    const pandora::TrackList *pTrackList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList<pandora::TrackList>(*this, pTrackList));

	std::cout << "PerfectPfoCreationAlgorithm:CreateTrackBasedPfos: track size: " << pTrackList->size() << std::endl;

    for (pandora::TrackList::const_iterator iter = pTrackList->begin(), iterEnd = pTrackList->end(); iter != iterEnd; ++iter)
    {
        const pandora::Track *const pTrack = *iter;
        PandoraContentApi::ParticleFlowObject::Parameters pfoParameters;

        // Walk along list of associated daughter/sibling tracks and their cluster associations
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->PopulateTrackBasedPfo(pTrack, pfoParameters));

        // Specify the pfo parameters
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->SetTrackBasedPfoParameters(pTrack, pfoParameters));

		//std::cout << "pfoParameters.energy: " << pfoParameters.m_energy.Get() << std::endl;

#if 0
		const pandora::ClusterList& clusterList = pfoParameters.m_clusterList;

		for(pandora::ClusterList::const_iterator clusterIter = clusterList.begin(), clusterIterEnd = clusterList.end(); 
		    clusterIter != clusterIterEnd; ++clusterIter)
		{
			bool clusterAvailability = (*clusterIter)->IsAvailable();

			if(!clusterAvailability) std::cout << "     *********cluster not Available, with energy : " 
				<< (*clusterIter)->GetHadronicEnergy() << std::endl;
		}
#endif

		//std::cout << "!!!!!! Track availability: " << pfoParameters.m_trackList << std::endl;
		//std::cout << "!!!!!! Cluster availability: " << pfoParameters.m_clusterList << std::endl;

        // Create the pfo
        const pandora::ParticleFlowObject *pPfo(NULL);
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::ParticleFlowObject::Create(*this, pfoParameters, pPfo));
#if 0
		//std::cout << "track based pfo, energy: " << pPfo->GetEnergy() << ", pfoParameters.energy: " 
		//	      << pfoParameters.m_energy.Get() << std::endl;

		const pandora::MCParticleWeightMap& mcpMap = pTrack->GetMCParticleWeightMap();

		if(mcpMap.empty()) std::cout << "MCP map is empty..." << std::endl;

		for(pandora::MCParticleWeightMap::const_iterator mapIter = mcpMap.begin(); mapIter != mcpMap.end(); ++mapIter) 
		{ 
			//std::map<const MCParticle *, float>
			const pandora::MCParticle* mcp = (*mapIter).first;
			float weight = (*mapIter).second;

			std::cout << "------> a MCP: energy: " << mcp->GetEnergy() 
				      << ", p: " << mcp->GetMomentum() 
				      << ", weight: " << weight << std::endl;
		}
#endif
    }
#endif

	/////////////
#if 1
    const pandora::MCParticleList *pMCParticleList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pMCParticleList));

	//std::cout << "MCP size: " << pMCParticleList->size() << std::endl;

    if (pMCParticleList->empty())
        return pandora::STATUS_CODE_SUCCESS;

    for (pandora::MCParticleList::const_iterator iterMC = pMCParticleList->begin(), iterMCEnd = pMCParticleList->end(); iterMC != iterMCEnd; ++iterMC)
    {
        try
        {
            const pandora::MCParticle *const pPfoTarget = *iterMC;
			//std::cout << "pfoTarget: " << pPfoTarget << std::endl;
            PfoParameters pfoParameters;

            this->CaloHitCollection(pPfoTarget, pfoParameters);
            this->TrackCollection(pPfoTarget, pfoParameters);

			/////
            int nTracksUsed(0);
            this->SetPfoParametersFromTracks(pPfoTarget, nTracksUsed, pfoParameters);
            this->SetPfoParametersFromClusters(pPfoTarget, nTracksUsed, pfoParameters);

#if 1
            if ((0 == nTracksUsed) && pfoParameters.m_clusterList.empty())
            {
                std::cout << pPfoTarget << " No energy deposits for pfo target " << pPfoTarget->GetParticleId() 
					      << ", E: " << pPfoTarget->GetEnergy() << std::endl;
                throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);
            }
#endif

            const pandora::ParticleFlowObject *pPfo(NULL);
            PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::ParticleFlowObject::Create(*this, pfoParameters, pPfo));
		}
        catch (pandora::StatusCodeException &)
		{
		}
	}
#endif

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PerfectPfoCreationAlgorithm::PopulateTrackBasedPfo(const pandora::Track *const pTrack, PfoParameters &pfoParameters, const bool readSiblingInfo) const
{
    // Add track to the pfo
    pfoParameters.m_trackList.push_back(pTrack);
	//std::cout << std::endl;

    // Add any cluster associated with this track to the pfo
    try
    {
        const pandora::Cluster *const pAssociatedCluster(pTrack->GetAssociatedCluster());
        pfoParameters.m_clusterList.push_back(pAssociatedCluster);
		//std::cout << "track, with energy: " << pTrack->GetEnergyAtDca() << ", added cluster" << std::endl;
    }
    catch (pandora::StatusCodeException &)
    {
		//std::cout << "track, with energy: " << pTrack->GetEnergyAtDca() << ", not add cluster" << std::endl;
    }

    // Consider any sibling tracks
    if (readSiblingInfo)
    {
        const pandora::TrackList &siblingTrackList(pTrack->GetSiblingList());

        for (pandora::TrackList::const_iterator iter = siblingTrackList.begin(), iterEnd = siblingTrackList.end(); iter != iterEnd; ++iter)
        {
            PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->PopulateTrackBasedPfo(*iter, pfoParameters, false));
        }
    }

    // Consider any daughter tracks
    const pandora::TrackList &daughterTrackList(pTrack->GetDaughterList());

    for (pandora::TrackList::const_iterator iter = daughterTrackList.begin(), iterEnd = daughterTrackList.end(); iter != iterEnd; ++iter)
    {
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->PopulateTrackBasedPfo(*iter, pfoParameters));
    }

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PerfectPfoCreationAlgorithm::SetTrackBasedPfoParameters(const pandora::Track *const pTrack, PfoParameters &pfoParameters) const
{
    const bool hasParent(!pTrack->GetParentList().empty());

    if (hasParent)
	{
		//std::cout << "!!!!!!! hasParent pandora::STATUS_CODE_NOT_ALLOWED " << std::endl;
        return pandora::STATUS_CODE_NOT_ALLOWED;
	}

    const bool hasSibling(!pTrack->GetSiblingList().empty());
    const bool hasDaughter(!pTrack->GetDaughterList().empty());

    if (hasSibling && hasDaughter)
	{
		//std::cout << "!!!!!!! hasSibling && hasDaughter pandora::STATUS_CODE_NOT_ALLOWED " << std::endl;
        return pandora::STATUS_CODE_NOT_ALLOWED;
	}

    if (hasSibling) {
		//std::cout << "hasSibling..." << std::endl;
        return this->SetSiblingTrackBasedPfoParameters(pTrack, pfoParameters);
	}

    if (hasDaughter) {
		//std::cout << "hasDaughter, this track energy: " << pTrack->GetEnergyAtDca() << std::endl;
        return this->SetDaughterTrackBasedPfoParameters(pTrack, pfoParameters);
	}

    return this->SetSimpleTrackBasedPfoParameters(pTrack, pfoParameters);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PerfectPfoCreationAlgorithm::SetSiblingTrackBasedPfoParameters(const pandora::Track *const pTrack, PfoParameters &pfoParameters) const
{
    int charge(0);
    float energy(0.f);
    pandora::CartesianVector momentum(0.f, 0.f, 0.f);

    pandora::TrackList fullSiblingTrackList(pTrack->GetSiblingList());
    fullSiblingTrackList.push_back(pTrack);

    for (pandora::TrackList::const_iterator iter = fullSiblingTrackList.begin(), iterEnd = fullSiblingTrackList.end(); iter != iterEnd; ++iter)
    {
        const pandora::Track *const pSiblingTrack = *iter;
        charge += pSiblingTrack->GetCharge();

        if (!pSiblingTrack->CanFormPfo() && !pSiblingTrack->CanFormClusterlessPfo())
            continue;

        // ATTN Assume sibling-track-based pfos represent pair-production
        const float electronMass(pandora::PdgTable::GetParticleMass(pandora::E_MINUS));
        energy += std::sqrt(electronMass * electronMass + pSiblingTrack->GetMomentumAtDca().GetMagnitudeSquared());
        momentum += pSiblingTrack->GetMomentumAtDca();
    }

    if (energy < std::numeric_limits<float>::epsilon())
        return pandora::STATUS_CODE_NOT_INITIALIZED;

    pfoParameters.m_energy = energy;
    pfoParameters.m_momentum = momentum;
    pfoParameters.m_mass = std::sqrt(std::max(energy * energy - momentum.GetDotProduct(momentum), 0.f));
    pfoParameters.m_charge = charge;
    pfoParameters.m_particleId = pandora::PHOTON;
	//std::cout << "PerfectPfoCreationAlgorithm::SetSiblingTrackBasedPfoParameters: " << energy << std::endl;

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PerfectPfoCreationAlgorithm::SetDaughterTrackBasedPfoParameters(const pandora::Track *const pTrack, PfoParameters &pfoParameters) const
{
    int daughterCharge(0);
    float energy(0.f);
    pandora::CartesianVector momentum(0.f, 0.f, 0.f);

    const pandora::TrackList &daughterTrackList(pTrack->GetDaughterList());
    const unsigned int nDaughters(daughterTrackList.size());

    for (pandora::TrackList::const_iterator iter = daughterTrackList.begin(), iterEnd = daughterTrackList.end(); iter != iterEnd; ++iter)
    {
        const pandora::Track *const pDaughterTrack = *iter;

        if (!pDaughterTrack->CanFormPfo() && !pDaughterTrack->CanFormClusterlessPfo())
            continue;

        daughterCharge += pDaughterTrack->GetCharge();
        energy += pDaughterTrack->GetEnergyAtDca();
		//std::cout << "daughter energy: " << pDaughterTrack->GetEnergyAtDca() << std::endl;
        momentum += pDaughterTrack->GetMomentumAtDca();

#if 0
		const pandora::MCParticleWeightMap& mcpMap = pDaughterTrack->GetMCParticleWeightMap();

		if(mcpMap.empty()) std::cout << "MCP map is empty..." << std::endl;

		for(pandora::MCParticleWeightMap::const_iterator mapIter = mcpMap.begin(); mapIter != mcpMap.end(); ++mapIter) 
		{ 
			//std::map<const MCParticle *, float>
			const pandora::MCParticle* mcp = (*mapIter).first;
			float weight = (*mapIter).second;

			std::cout << "------> a MCP: energy: " << mcp->GetEnergy() 
				      << ", p: " << mcp->GetMomentum() 
				      << ", weight: " << weight << std::endl;
		}
#endif
    }

    pfoParameters.m_energy = energy;
    pfoParameters.m_momentum = momentum;
    pfoParameters.m_mass = std::sqrt(std::max(energy * energy - momentum.GetDotProduct(momentum), 0.f));
    pfoParameters.m_charge = (nDaughters > 1) ? pTrack->GetCharge() : daughterCharge;
    pfoParameters.m_particleId = (pfoParameters.m_charge.Get() > 0) ? pandora::PI_PLUS : pandora::PI_MINUS;
	//std::cout << "PerfectPfoCreationAlgorithm::SetDaughterTrackBasedPfoParameters: " << energy << std::endl;

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PerfectPfoCreationAlgorithm::SetSimpleTrackBasedPfoParameters(const pandora::Track *const pTrack, PfoParameters &pfoParameters) const
{
    pfoParameters.m_energy = pTrack->GetEnergyAtDca();
    pfoParameters.m_momentum = pTrack->GetMomentumAtDca();
    pfoParameters.m_mass = pTrack->GetMass();
    pfoParameters.m_charge = pTrack->GetCharge();
    pfoParameters.m_particleId = (pTrack->GetCharge() > 0) ? pandora::PI_PLUS : pandora::PI_MINUS;

	float chi = 0.;

	try
	{
    const pandora::Cluster *const pAssociatedCluster(pTrack->GetAssociatedCluster());

	if(pAssociatedCluster==NULL) return pandora::STATUS_CODE_SUCCESS;


        chi = ReclusterHelper::GetTrackClusterCompatibility(this->GetPandora(),  
			                                                  pAssociatedCluster->GetHadronicEnergy(), pTrack->GetEnergyAtDca());
	
		//std::cout << "SetSimpleTrackBasedPfoParameters: chi: " << chi << ", E_track: " << pTrack->GetEnergyAtDca()
		//<< ", E_cluster: " << pAssociatedCluster->GetHadronicEnergy() << std::endl;

	    if(chi>5.)
	    {
	    	//pfoParameters.m_energy = pAssociatedCluster->GetCorrectedHadronicEnergy(this->GetPandora());
	    	pfoParameters.m_energy = pAssociatedCluster->GetHadronicEnergy();
	    	pfoParameters.m_particleId = pandora::NEUTRON;
	    	pfoParameters.m_mass = pandora::PdgTable::GetParticleMass(pandora::NEUTRON);
	    	pfoParameters.m_charge = 0;

	    	// FIXME momentum
            //const pandora::CartesianVector momentum(positionVector.GetUnitVector() * clusterEnergy);
            //pfoParameters.m_momentum = momentum;
	    }
	}
    catch (pandora::StatusCodeException &)
	{
		std::cout << "chi is not available" << std::endl;
	}


    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PerfectPfoCreationAlgorithm::CreateNeutralPfos() const
{
    const pandora::ClusterList *pClusterList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));
	//std::cout << "check the cluster again: " << pClusterList->size() << std::endl;

    // Examine clusters with no associated tracks to form neutral pfos
    for (pandora::ClusterList::const_iterator iter = pClusterList->begin(), iterEnd = pClusterList->end(); iter != iterEnd; ++iter)
    {
        const pandora::Cluster *const pCluster = *iter;

        if (!pCluster->GetAssociatedTrackList().empty())
            continue;

        if (pCluster->GetNCaloHits() < m_minHitsInCluster)
            continue;

        const bool isPhoton(pCluster->PassPhotonId(this->GetPandora()));
        float clusterEnergy(isPhoton ? pCluster->GetCorrectedElectromagneticEnergy(this->GetPandora()) : pCluster->GetCorrectedHadronicEnergy(this->GetPandora()));

		//std::cout << "----cluster energy: " << pCluster->GetElectromagneticEnergy() << std::endl;
		//std::cout << "----- h_energy: " << pCluster->GetCorrectedHadronicEnergy(this->GetPandora()) << std::endl;

        // Veto non-photon clusters below hadronic energy threshold and those occupying a single layer
        if (!isPhoton)
        {
            if (clusterEnergy < m_minClusterHadronicEnergy)
                continue;

            if (!m_allowSingleLayerClusters && (pCluster->GetInnerPseudoLayer() == pCluster->GetOuterPseudoLayer()))
                continue;
        }
        else
        {
            if (clusterEnergy < m_minClusterElectromagneticEnergy)
                continue;
        }

        // Specify the pfo parameters
        PandoraContentApi::ParticleFlowObject::Parameters pfoParameters;
        pfoParameters.m_particleId = (isPhoton ? pandora::PHOTON : pandora::NEUTRON);
        pfoParameters.m_charge = 0;
        pfoParameters.m_mass = (isPhoton ? pandora::PdgTable::GetParticleMass(pandora::PHOTON) : pandora::PdgTable::GetParticleMass(pandora::NEUTRON));
        pfoParameters.m_energy = clusterEnergy;

		//std::cout << "----- energy: " << clusterEnergy << std::endl;
        pfoParameters.m_clusterList.push_back(pCluster);

        // Photon position: 0) unweighted inner centroid, 1) energy-weighted inner centroid, 2+) energy-weighted centroid for all layers
        pandora::CartesianVector positionVector(0.f, 0.f, 0.f);
        const unsigned int clusterInnerLayer(pCluster->GetInnerPseudoLayer());

        if (!isPhoton || (0 == m_photonPositionAlgorithm))
        {
            positionVector = pCluster->GetCentroid(clusterInnerLayer);
        }
        else if (1 == m_photonPositionAlgorithm)
        {
            positionVector = this->GetEnergyWeightedCentroid(pCluster, clusterInnerLayer, clusterInnerLayer);
        }
        else
        {
            positionVector = this->GetEnergyWeightedCentroid(pCluster, clusterInnerLayer, pCluster->GetOuterPseudoLayer());
        }

        const pandora::CartesianVector momentum(positionVector.GetUnitVector() * clusterEnergy);
        pfoParameters.m_momentum = momentum;

        const pandora::ParticleFlowObject *pPfo(NULL);
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::ParticleFlowObject::Create(*this, pfoParameters, pPfo));
    }

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

const pandora::CartesianVector PerfectPfoCreationAlgorithm::GetEnergyWeightedCentroid(const pandora::Cluster *const pCluster, const unsigned int innerPseudoLayer,
    const unsigned int outerPseudoLayer) const
{
    float energySum(0.f);
    pandora::CartesianVector energyPositionSum(0.f, 0.f, 0.f);
    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());

    for (pandora::OrderedCaloHitList::const_iterator iter = orderedCaloHitList.begin(), iterEnd = orderedCaloHitList.end(); iter != iterEnd; ++iter)
    {
        if (iter->first > outerPseudoLayer)
            break;

        if (iter->first < innerPseudoLayer)
            continue;

        for (pandora::CaloHitList::const_iterator hitIter = iter->second->begin(), hitIterEnd = iter->second->end(); hitIter != hitIterEnd; ++hitIter)
        {
            const float electromagneticEnergy((*hitIter)->GetElectromagneticEnergy());
            energySum += electromagneticEnergy;
            energyPositionSum += ((*hitIter)->GetPositionVector() * electromagneticEnergy);
        }
    }

    if (energySum < std::numeric_limits<float>::epsilon())
        throw pandora::StatusCodeException(pandora::STATUS_CODE_NOT_INITIALIZED);

    return (energyPositionSum * (1.f / energySum));
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PerfectPfoCreationAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "OutputPfoListName", m_outputPfoListName));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ShouldCreateTrackBasedPfos", m_shouldCreateTrackBasedPfos));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ShouldCreateNeutralPfos", m_shouldCreateNeutralPfos));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinClusterHadronicEnergy", m_minClusterHadronicEnergy));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinClusterElectromagneticEnergy", m_minClusterElectromagneticEnergy));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinHitsInCluster", m_minHitsInCluster));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "AllowSingleLayerClusters", m_allowSingleLayerClusters));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhotonPositionAlgorithm", m_photonPositionAlgorithm));

    return pandora::STATUS_CODE_SUCCESS;
}

}

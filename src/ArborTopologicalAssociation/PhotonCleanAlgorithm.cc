/// \file PhotonCleanAlgorithm.cc
/*
 *
 * PhotonCleanAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. juin 30 2016
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborTopologicalAssociation/PhotonCleanAlgorithm.h"

#include "Pandora/AlgorithmHeaders.h"

#include "ArborHelpers/SortingHelper.h"
#include "ArborHelpers/GeometryHelper.h"
#include "ArborHelpers/ReclusterHelper.h"
#include "ArborHelpers/ClusterHelper.h"
#include "ArborHelpers/CaloHitHelper.h"
#include "ArborTools/CaloHitMergingTool.h"

namespace arbor_content
{

  pandora::StatusCode PhotonCleanAlgorithm::Run()
  {
	std::cout << "======= PhotonCleanAlgorithm ====== " << std::endl;

    const pandora::ClusterList *pClusterList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

    if(pClusterList->empty())
      return pandora::STATUS_CODE_SUCCESS;

    // loop over clusters
    for(auto clusterIter = pClusterList->begin(), clusterEndIter = pClusterList->end();
        clusterEndIter != clusterIter ; ++clusterIter)
    {
      const pandora::Cluster *const pCluster(*clusterIter);

	  try
	  {
		 //auto pClusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle(pCluster);
	     //int clusterPID = pClusterMCParticle->GetParticleId();
	     //int clusterMCPCharge = pandora::PdgTable::GetParticleCharge(clusterPID);

		 bool isPhoton = PandoraContentApi::GetPlugins(*this)->GetParticleId()->IsPhoton(pCluster);
#if 0
                 bool isPhoton1 = pCluster->PassPhotonId(this->GetPandora()) && pCluster->GetAssociatedTrackList().empty();
		 if(isPhoton != isPhoton1) 
		 {
			 std::cout << " --- cluster: " << pCluster << ", Ehad: " << pCluster->GetHadronicEnergy() 
				       << ", isPhoton: " << isPhoton << ", isPhoton1: " << isPhoton1 << std::endl;
		 }
#endif
	  
		 if(isPhoton)
		 {
#if 0
			 std::cout << " --- cluster: " << pCluster << ", Ehad: " << pCluster->GetHadronicEnergy() 
				       << ", clusterPID: " << clusterPID << ", chg: " << clusterMCPCharge 
			           << ", isPhoton :" <<  pCluster->PassPhotonId(this->GetPandora()) 
					   << ", averageTime: " << ClusterHelper::GetAverageTime(pCluster) << std::endl;
#endif

	         pandora::CaloHitList clusterCaloHitList;
	         pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

		     pandora::CartesianVector centroid(0., 0., 0);
		     ClusterHelper::GetCentroid(pCluster, centroid);

	         for(auto hitIter = clusterCaloHitList.begin(); hitIter != clusterCaloHitList.end(); ++hitIter)
	         {
	         	auto pCaloHit = *hitIter;

				//pandora::CartesianVector hitPos = pCaloHit->GetPositionVector();
				//pandora::CartesianVector posDiff = hitPos - centroid;
	            //std::cout << "hit time: " << pCaloHit->GetTime() << ", ditanct to COG: " << posDiff.GetMagnitude() << std::endl;
				float hitTime = pCaloHit->GetTime();

				if(hitTime > m_maxHitTimeForClean)
				{
					ArborContentApi::RemoveFromCluster(*this, pCluster, pCaloHit);
				}
	         }
		 }
	  }
	  catch (pandora::StatusCodeException &)
	  {
	  }
	}

    return pandora::STATUS_CODE_SUCCESS;

  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode PhotonCleanAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    m_maxHitTimeForClean = 11.;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxHitTimeForClean", m_maxHitTimeForClean));

    return pandora::STATUS_CODE_SUCCESS;
  }

}

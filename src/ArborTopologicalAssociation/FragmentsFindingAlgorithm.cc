/// \file FragmentsFindingAlgorithm.cc
/*
 *
 * FragmentsFindingAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. juin 30 2016
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborTopologicalAssociation/FragmentsFindingAlgorithm.h"

#include "Pandora/AlgorithmHeaders.h"

#include "ArborHelpers/SortingHelper.h"
#include "ArborHelpers/GeometryHelper.h"
#include "ArborHelpers/ReclusterHelper.h"
#include "ArborHelpers/ClusterHelper.h"
#include "ArborHelpers/CaloHitHelper.h"
#include "ArborTools/CaloHitMergingTool.h"
#include "ArborHelpers/HistogramHelper.h"

namespace arbor_content
{

  pandora::StatusCode FragmentsFindingAlgorithm::Run()
  {
	std::cout << "======= FragmentsFindingAlgorithm ====== " << std::endl;

    // find fragments 
    pandora::ClusterVector removalClusterVector;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindClusterFragments(removalClusterVector));

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode FragmentsFindingAlgorithm::FindClusterFragments(pandora::ClusterVector &removalClusterVector) const
  {
    const pandora::ClusterList *pClusterList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

    if(pClusterList->empty())
      return pandora::STATUS_CODE_SUCCESS;

    pandora::ClusterVector clusterVector(pClusterList->begin(), pClusterList->end());
    pandora::ClusterVector nonFragmentsClusterVector;
    pandora::ClusterVector potentialFragmentsClusterVector;

    // loop over clusters and identify fragments
    for(pandora::ClusterVector::iterator clusterIter = clusterVector.begin(), clusterEndIter = clusterVector.end() ;
        clusterEndIter != clusterIter ; ++clusterIter)
    {
      const pandora::Cluster *const pCluster(*clusterIter);
	  float hadEnergy = pCluster->GetHadronicEnergy();
	  int clusterPID = -1e6;
	  int clusterMCPCharge = -1000;
	  float averageTime = -1.;

	  // FIXME
	  if(hadEnergy < 0.2) continue;

	  try
	  {
		 auto pClusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle(pCluster);
	     clusterPID = pClusterMCParticle->GetParticleId();
	     clusterMCPCharge = pandora::PdgTable::GetParticleCharge(clusterPID);
		 averageTime  = ClusterHelper::GetAverageTime(pCluster);
	  }
	  catch (pandora::StatusCodeException &)
	  {
	  }

      // enough hits or energy for a real cluster
      //if(pCluster->GetNCaloHits() > m_maxNHitsNonFragments || pCluster->GetHadronicEnergy() > m_maxEnergyNonFragments)
	  int nHit = pCluster->GetNCaloHits();
	  bool isPhoton = PandoraContentApi::GetPlugins(*this)->GetParticleId()->IsPhoton(pCluster);
      bool hasTrack = !(pCluster->GetAssociatedTrackList().empty());

      float meanDensity = -1.;
      ClusterHelper::GetMeanDensity(pCluster, meanDensity);

	  /////////////////////
	  std::vector<float> vars;
	  vars.push_back( float(clusterPID) );
	  vars.push_back( float(clusterMCPCharge) );
	  vars.push_back( float(averageTime) );
	  vars.push_back( float(nHit) );
	  vars.push_back( hadEnergy );
	  vars.push_back( float(isPhoton) );
	  vars.push_back( float(hasTrack) );
	  vars.push_back( meanDensity );
	  HistogramManager::CreateFill("FragmentsFindingAlgorithm", "clusterPID:clusterMCPCharge:averageTime:nHit:clusterEnergy:isPhoton:hasTrack:meanDensity", vars);
        
	  //std::cout << " ------ potentialFragments" << std::endl;
	  potentialFragmentsClusterVector.push_back(pCluster);
    }

	removalClusterVector = potentialFragmentsClusterVector;

	//std::cout << " --- removalClusterVector: " << removalClusterVector.size() << std::endl;

    for(pandora::ClusterVector::const_iterator fragIter = potentialFragmentsClusterVector.begin(); 
	    fragIter != potentialFragmentsClusterVector.end(); ++fragIter)
	{
		const pandora::Cluster *const pFragment(*fragIter);
		auto pArborFragment = ArborContentApi::Modifiable(dynamic_cast<const arbor_content::ArborCluster*>(pFragment));
		pArborFragment->SetFragment();
	}
		
    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode FragmentsFindingAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    m_maxNHitsNonFragments = 200;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxNHitsNonFragments", m_maxNHitsNonFragments));

    m_maxEnergyNonFragments = 5.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxEnergyNonFragments", m_maxEnergyNonFragments));

    m_maxFragmentDensity = 0.5f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxFragmentDensity", m_maxFragmentDensity));

    return pandora::STATUS_CODE_SUCCESS;
  }

} 


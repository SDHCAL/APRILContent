/// \file ClusterEfficiencyAlgorithm.cc
/*
 *
 * ClusterEfficiencyAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. juin 2 2016
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborUtility/ClusterEfficiencyAlgorithm.h"

#include "Pandora/AlgorithmHeaders.h"
#include "ArborApi/ArborContentApi.h"
#include "ArborObjects/CaloHit.h"
#include "ArborHelpers/GeometryHelper.h"
#include "ArborHelpers/ReclusterHelper.h"

#include "ArborHelpers/HistogramHelper.h"
using namespace pandora;

namespace arbor_content
{

  pandora::StatusCode ClusterEfficiencyAlgorithm::Run()
  {
    extern HistogramManager AHM;

	////////
    const pandora::PfoList *pPfoList = NULL; 
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pPfoList));
	std::cout << "------- # PFO : " << pPfoList->size() << std::endl;

	std::map<const pandora::MCParticle* const, pandora::CaloHitList> mcpCaloHitListMap;
	std::map<const pandora::MCParticle* const, pandora::ClusterList> mcpClusterListMap;

    for(pandora::PfoList::const_iterator iter = pPfoList->begin(), endIter = pPfoList->end(); endIter != iter ; ++iter)
    {
		const pandora::ParticleFlowObject* pfo = *iter;
		//std::cout << "PFO : " << pfo << ", PID: " << pfoPID << ", charge: " << pfoCharge << std::endl;

		const pandora::ClusterList& pfoClusterList = pfo->GetClusterList();
    
		for(pandora::ClusterList::const_iterator cluIter = pfoClusterList.begin(); cluIter != pfoClusterList.end(); ++cluIter)
		{
			const pandora::Cluster* pfoCluster = *cluIter;

			const pandora::MCParticle* pMCClusterParticle = NULL;
	  
			try 
			{
				pMCClusterParticle = pandora::MCParticleHelper::GetMainMCParticle(pfoCluster);
			}
    		catch (pandora::StatusCodeException &)
			{
				continue;
			}

			// make MCP and cluster relationship
			if(pMCClusterParticle != NULL && mcpCaloHitListMap.find(pMCClusterParticle) == mcpCaloHitListMap.end())
			{
				pandora::ClusterList cluList;
				cluList.push_back( pfoCluster );
				mcpClusterListMap[pMCClusterParticle] = cluList;
			}
			else
			{
				mcpClusterListMap[pMCClusterParticle].push_back( pfoCluster );
			}

			// make MCP and hit relationship
	        pandora::CaloHitList caloHitList;
	        pfoCluster->GetOrderedCaloHitList().FillCaloHitList(caloHitList);

            for(pandora::CaloHitList::const_iterator caloHitIter = caloHitList.begin(); caloHitIter != caloHitList.end(); ++caloHitIter)
            {
               const pandora::CaloHit* caloHit = *caloHitIter;
			   const pandora::MCParticle* pMCHitParticle  = NULL;

               try
               {
               	 pMCHitParticle = pandora::MCParticleHelper::GetMainMCParticle(caloHit);
               	//std::cout << "calo hit: " << caloHit << ", mcp: " << pMCHitParticle << std::endl;
               }
               catch (pandora::StatusCodeException &)
               {
				   continue;
               }

			   if(pMCHitParticle != NULL && mcpCaloHitListMap.find( pMCHitParticle ) == mcpCaloHitListMap.end())
			   {
				   pandora::CaloHitList hitList;
				   hitList.push_back( caloHit );
				   mcpCaloHitListMap[pMCHitParticle] = hitList;
			   }
			   else
			   {
				   mcpCaloHitListMap[pMCHitParticle].push_back( caloHit );
			   }
	        }
		} // for each cluster
	} // for each pfo

	/////////////

	for(auto it = mcpCaloHitListMap.begin(); it != mcpCaloHitListMap.end(); ++it)
	{
		auto mcp = it->first;

	    // all the hits belong to the mcp based on the MC information
		auto mcpHitList = it->second;

		// all the clusters which has the main mcp 
		auto clusterList = mcpClusterListMap[mcp];
		// the hits from the clusters above
		pandora::CaloHitList clusterHitList;

		for(auto cluListIt = clusterList.begin(); cluListIt != clusterList.end(); ++cluListIt)
		{
			auto pCluster = *cluListIt;

			pandora::CaloHitList caloHitList;
			pCluster->GetOrderedCaloHitList().FillCaloHitList(caloHitList);

            for(pandora::CaloHitList::const_iterator caloHitIter = caloHitList.begin();
				caloHitIter != caloHitList.end(); ++caloHitIter)
            {
               const pandora::CaloHit* caloHit = *caloHitIter;

			   clusterHitList.push_back( caloHit );
	        }
		}

		float mcpHitEnergy = 0.;
		float collectedEnergy = 0.;
		float clusterSize = 0.;

		for(auto hitIt = mcpHitList.begin(); hitIt != mcpHitList.end(); ++hitIt)
		{
			auto hit = *hitIt;

			float hitEnergy = hit->GetHadronicEnergy();
			mcpHitEnergy += hitEnergy;

			clusterSize += 1;

			if( std::find( clusterHitList.begin(), clusterHitList.end(), *hitIt ) != clusterHitList.end() )
			{
				collectedEnergy += hitEnergy;
			}
		}

	     std::vector<float> vars;
	     vars.push_back( clusterSize );
	     vars.push_back( mcpHitEnergy );
	     vars.push_back( collectedEnergy/mcpHitEnergy );
	
	     AHM.CreateFill("ClusterEfficiency", "clusterSize:clusterEnergy:clusterEfficiency", vars);
	}

    return pandora::STATUS_CODE_SUCCESS;
  }

  pandora::StatusCode ClusterEfficiencyAlgorithm::Initialize()
  {
	  return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterEfficiencyAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    return pandora::STATUS_CODE_SUCCESS;
  }

}

/// \file ChargedFragmentsMergingAlgorithm3.cc
/*
 *
 * ChargedFragmentsMergingAlgorithm3.cc source template automatically generated by a class generator
 * Creation date : jeu. avr. 9 2015
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#include "Pandora/AlgorithmHeaders.h"
#include "PandoraMonitoringApi.h"
#include "PandoraMonitoring.h"

#include "ArborTopologicalAssociation/ChargedFragmentsMergingAlgorithm3.h"

#include "ArborHelpers/SortingHelper.h"
#include "ArborHelpers/GeometryHelper.h"
#include "ArborHelpers/ReclusterHelper.h"
#include "ArborHelpers/ClusterHelper.h"
#include "ArborHelpers/HistogramHelper.h"
#include "ArborHelpers/ClusterPropertiesHelper.h"

#include "ArborApi/ArborContentApi.h"

#include "ArborUtility/EventPreparationAlgorithm.h"

#include "ArborTools/TrackDrivenSeedingTool.h"
#include "ArborObjects/CaloHit.h"

#include "TMath.h"

#include <algorithm>

namespace arbor_content
{
  pandora::StatusCode ChargedFragmentsMergingAlgorithm3::Run()
  {
    // get candidate clusters for association
	std::vector<ArborCluster*> clusterVector;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->GetEligibleClusters(clusterVector));

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	std::vector<pandora::CartesianVector> m_clusterCentroids;

	for(auto clu : clusterVector)
	{
		auto& centroid = clu->GetCentroid();
		m_clusterCentroids.push_back(centroid);
	}

	CaloHitRangeSearchHelper::FillMatixByPoints(m_clusterCentroids, m_clusterCentroidsMatrix);

	pandora::ClusterList clustersForMerging;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	for(int i = 0; i < clusterVector.size(); ++i)
	{
		auto pCluster = clusterVector.at(i);

		const pandora::TrackList& associatedTrackList = pCluster->GetAssociatedTrackList();
		if(!associatedTrackList.empty()) 
		{
			clustersForMerging.push_back(pCluster);
			continue;
		}

		bool isPhoton = pCluster->IsPhoton();

#if 0
		bool useMCPForPID = false;
		if(useMCPForPID)
		{
			const pandora::Cluster* const pandoraClu = dynamic_cast<const pandora::Cluster* const>(pCluster);

			try
		    {
		    	isPhoton = pandora::MCParticleHelper::GetMainMCParticle(pandoraClu)->GetParticleId() == 22;
		    }
		    catch(pandora::StatusCodeException &)
		    {
		    	std::cout << "MCP issue: " << pandoraClu << std::endl;
		    }
		}
#endif
		
		if(isPhoton) continue;

		int clusterPID = -1e8;
		int clusterCharge = -1000;

		const pandora::Cluster* const pandoraClu = dynamic_cast<const pandora::Cluster* const>(pCluster);

		try
		{
			clusterPID = pandora::MCParticleHelper::GetMainMCParticle(pandoraClu)->GetParticleId();
			clusterCharge = pandora::PdgTable::GetParticleCharge( clusterPID );
		
			if(m_useMCPForPID) isPhoton = (clusterPID == 22);
		}
		catch(pandora::StatusCodeException &)
		{
			std::cout << "MCP issue: " << pandoraClu << std::endl;
		}

		std::cout << " --- cluster : " << pCluster << ", energy: " << pCluster->GetHadronicEnergy() << ", PID: " <<
			clusterPID << ", charge: " << clusterCharge << std::endl;

		if(m_debugOutput)
		{
			std::cout << "-----------------------------------------------------------------------------------------" << std::endl;
			std::cout << " --- cluster : " << pCluster << ", energy: " << pCluster->GetHadronicEnergy() 
				  << ", associatedTrackList size: " << pCluster->GetAssociatedTrackList().size() << std::endl;
		}

#if 1
		auto clusterRegion = ClusterHelper::GetRegion(pCluster);

		float clusterIPAngle = ClusterHelper::GetClusterAxisStartingPointAngle(pCluster);
		float clusterTime = ClusterHelper::GetAverageTime(pCluster);
		float clusterTimeECal = ClusterHelper::GetAverageTime(pCluster, true);
		float hadEnergyInEcal = ClusterHelper::GetHadronicEnergyInECAL(pCluster);
		float density = ClusterHelper::GetMeanDensity(pCluster);

		float energyRatio = hadEnergyInEcal / pCluster->GetHadronicEnergy();

		const pandora::OrderedCaloHitList& mainClusterHits = pCluster->GetMainClusterHits();
		
		float energyRatioOfMainHits;
	   	unsigned int nMainHits;
	   
		ClusterHelper::GetEnergyRatio(mainClusterHits, energyRatioOfMainHits, nMainHits);

		unsigned int innerLayer = pCluster->GetInnerPseudoLayer();
		unsigned int outerLayer = pCluster->GetOuterPseudoLayer();

		unsigned int nConnectors = ClusterHelper::GetClusterConnectorNumber(pCluster);
		float connectorHitRatio = (float)nConnectors/nMainHits;
	    
		std::vector<arbor_content::ArborCluster*> nearbyClusters;

		try
		{
			SearchProperClusters(pCluster, clusterVector, nearbyClusters);
		}
		catch(...)
		{
			std::cout << " GetNearbyClusters error!" << std::endl;
		}

		/////////////////////////////////////////////////////////////////
		bool nearClusterHasTrack = false;

	    for(int iClu = 0; iClu < nearbyClusters.size(); ++iClu)
	    {
	    	//std::cout << "       ---> cluster: " << nearbyClusters.at(iClu) << ", E: " << nearbyClusters.at(iClu)->GetHadronicEnergy() 
	    	//	<< ", associatedTrack: " << nearbyClusters.at(iClu)->GetAssociatedTrackList().size() << std::endl;

			if(nearbyClusters.at(iClu)->GetAssociatedTrackList().size() > 0)
			{
				nearClusterHasTrack = true;
			}
	    }

		if(nearClusterHasTrack)
		{
			clustersForMerging.push_back(pCluster);
			continue;
		}
		/////////////////////////////////////////////////////////////////

		if(m_debugOutput)
		{
			std::cout << "    === cluster === " << std::endl
	        	      << "    cluster: " << pCluster << ", E: " << pCluster->GetHadronicEnergy()  << ", nhit: " 
					  << pCluster->GetNCaloHits() << std::endl
	        		  << "    nPossibleMipHits: " << pCluster->GetNPossibleMipHits() << ", mipFraction: " << pCluster->GetMipFraction() << std::endl
	        		  << "    isPhoton: " << isPhoton << std::endl
	        		  << "    clusterRegion: " << clusterRegion << " clusterIPAngle: " << clusterIPAngle << " clusterTime: " 
					  << clusterTime << " clusterTimeECal: " << clusterTimeECal << std::endl
	        		  << "    hadEnergyInEcal: " << hadEnergyInEcal << " energyRatio: " << energyRatio << std::endl
	        		  << "    density: " << density << ", connectorHitRatio: " << connectorHitRatio << std::endl
	        		  << "    innerLayer: " << innerLayer << " outerLayer: " << outerLayer << std::endl
	        		  << "    nearby cluster: " << nearbyClusters.size() << std::endl;

	            for(int iClu = 0; iClu < nearbyClusters.size(); ++iClu)
	            {
	            	std::cout << "       ---> cluster: " << nearbyClusters.at(iClu) << ", E: " << nearbyClusters.at(iClu)->GetHadronicEnergy() 
	            		<< ", associatedTrack: " << nearbyClusters.at(iClu)->GetAssociatedTrackList().size() << std::endl;
	            }

	        	std::cout << "    clusterMCPID: " << clusterPID << ", clusterMCCharge: " << clusterCharge << std::endl;
		}

		//bool isChargedCluster = false;

		if(innerLayer > 30 || energyRatio < 0.3)
		{
			//std::cout << "    \033[1;31m ---> innerLayer: " << innerLayer << ", energyRatio: " << energyRatio << " \033[0m " << std::endl;
			clustersForMerging.push_back(pCluster);
			continue;
		}

		//fakePhoton = !CheckNearbyClusterWithCharge(pCluster, nearbyClusters, 1);
		//fakePhoton = !CheckNearbyClusterWithCharge(pCluster, nearbyClusters, 0);

		if(m_makeRecord)
		{
			// For efficiency and purity
		    std::vector<float> vars;
	        vars.push_back( float(hadEnergyInEcal) );
	        vars.push_back( float(clusterCharge) );
	        vars.push_back( float(clusterPID) );
		    	    		
		    HistogramManager::CreateFill("NewPhotonID_eff", "hadEnergyInEcal:mcCharge:mcPID", vars);
		}
#endif
		
	}

	// cluster merging test
	std::map<const pandora::MCParticle* const, pandora::ClusterList> mcpClusterListMap;
	
	for(auto it = clustersForMerging.begin(); it != clustersForMerging.end(); ++it)
	{
		const pandora::Cluster* const clu = *it;

		const pandora::MCParticle* pClusterMCParticle  = nullptr;

        try
        {
        	 pClusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle( clu );
        }
        catch (pandora::StatusCodeException &)
        {
		    continue;
		}

		if(pClusterMCParticle != nullptr && mcpClusterListMap.find( pClusterMCParticle ) == mcpClusterListMap.end())
		{
		    pandora::ClusterList clusterList;
		    clusterList.push_back( clu );
		    mcpClusterListMap[pClusterMCParticle] = clusterList;
		}
		else
		{
		    mcpClusterListMap[pClusterMCParticle].push_back( clu );
		}
	}

	for(auto it = mcpClusterListMap.begin(); it != mcpClusterListMap.end(); ++it)
	{
		// merge charged clusters
		auto mcp = it->first;
		int clusterMCPCharge = pandora::PdgTable::GetParticleCharge(mcp->GetParticleId());

		auto clusterList = it->second;
		pandora::ClusterVector clusterVectorForMerging;
		clusterVectorForMerging.insert(clusterVectorForMerging.begin(), clusterList.begin(), clusterList.end());

		if(clusterMCPCharge == 0) 
		{
			std::cout << "      \033[1;32m Neutral cluster(s): \033[0m" << std::endl;

			for(int i = 0; i < clusterVectorForMerging.size(); ++i)
			{
				auto& cluster = clusterVectorForMerging.at(i);
				std::cout << "             ---> cluster: " << cluster << ", E: " << cluster->GetHadronicEnergy() << std::endl;
			}

			continue;
		}
		else
		{
			std::cout << "      \033[1;31m Charged cluster(s): \033[0m" << std::endl;

			for(int i = 0; i < clusterVectorForMerging.size(); ++i)
			{
				auto& cluster = clusterVectorForMerging.at(i);
				std::cout << "             ---> cluster: " << cluster << ", E: " << cluster->GetHadronicEnergy() << std::endl;
			}
		}
	
		std::sort(clusterVectorForMerging.begin(), clusterVectorForMerging.end(), pandora_monitoring::PandoraMonitoring::SortClustersByHadronicEnergy);

	    if(clusterVectorForMerging.size()>1) 
		{
			// merge clusters
			auto firstCluster = clusterVectorForMerging.at(0);

			for(int i = 1; i < clusterVectorForMerging.size(); ++i)
			{
		        const pandora::Cluster* cluToMerge = clusterVectorForMerging.at(i);
#if 0
                if(firstCluster->GetAssociatedTrackList().size() > 0 && cluToMerge->GetAssociatedTrackList().size() > 0) continue;
				if(cluToMerge->GetHadronicEnergy() < m_minClusterEnergyToMerge) continue;

				///
		        float closestDistance = -1.e6;

		        try
		        {
		            ClusterHelper::GetClosestDistanceApproach(firstCluster, cluToMerge, closestDistance, false);
		        }
                catch(pandora::StatusCodeException &)
		        {
		            std::cout << "GetClosestDistanceApproach failed" << std::endl;
		        }

				bool firstClusterHasTrack = !(firstCluster->GetAssociatedTrackList().empty());
				bool cluToMergeHasTrack = !(cluToMerge->GetAssociatedTrackList().empty());

	            std::vector<float> vars;
	            vars.push_back( float(EventPreparationAlgorithm::GetEventNumber()) );
	            vars.push_back( float(firstCluster->GetHadronicEnergy()) );
	            vars.push_back( float(cluToMerge->GetHadronicEnergy()) );
				vars.push_back( float(clusterMCPCharge));
				vars.push_back( float(isPhoton));
				vars.push_back( closestDistance );
				vars.push_back( float(firstClusterHasTrack) );
				vars.push_back( float(cluToMergeHasTrack) );

				//std::cout << "  -> cluster energy to merge: " << cluToMerge->GetHadronicEnergy() << std::endl;

		        HistogramManager::CreateFill(tupleName.c_str(), "evtNumber:mainClusterEnergy:clusterEnergy:clusterMCPCharge:isMCPPhoton:closestDistance:firstClusterHasTrack:cluToMergeHasTrack", vars);

				auto pArborFirstCluster = ArborContentApi::Modifiable(dynamic_cast<const arbor_content::ArborCluster*>(firstCluster));
				auto pArborCluToMerge = ArborContentApi::Modifiable(dynamic_cast<const arbor_content::ArborCluster*>(cluToMerge));

				float clusterAngle1 = ClusterHelper::GetClusterAxisStartingPointAngle(pArborFirstCluster);
				float clusterAngle2 = ClusterHelper::GetClusterAxisStartingPointAngle(pArborCluToMerge);

				float cluster1Time = ClusterHelper::GetAverageTime(pArborFirstCluster);
				float cluster2Time = ClusterHelper::GetAverageTime(pArborCluToMerge);

				std::cout << "     === Cluster to merge: " << std::endl
					      << "         mainCluster " << firstCluster << ", Ehad: " << firstCluster->GetHadronicEnergy() << ", region: " << ClusterHelper::GetRegion(firstCluster) << ", angle: " << clusterAngle1 << ", time: " << cluster1Time << std::endl
					      << "         cluToMerge " << cluToMerge    << ", Ehad: " << cluToMerge->GetHadronicEnergy() << ", region: " << ClusterHelper::GetRegion(cluToMerge) << ", angle: " << clusterAngle2 << ", time: " << cluster2Time << std::endl
					      << "         cluster charge: " << clusterMCPCharge << std::endl;

				if(clusterMCPCharge != 0)
				{
					std::cout << "     \033[1;31m=== merge two CHARGED clusters: " << firstCluster << ", E: " << firstCluster->GetHadronicEnergy() 
						      << " --- " << cluToMerge << ", E: " << cluToMerge->GetHadronicEnergy() 
							  << ", distance: " << closestDistance << "\033[0m" << std::endl;
				}
#endif

				ArborContentApi::MergeAndDeleteClusters(*this, firstCluster, cluToMerge);
			}

		}// end if
	} // end for

    return pandora::STATUS_CODE_SUCCESS;
  }

  bool ChargedFragmentsMergingAlgorithm3::CheckNearbyClusterWithCharge(const arbor_content::ArborCluster* pCluster, std::vector<arbor_content::ArborCluster*>& nearbyClusters, int charge)
  {
	  bool isValidated = true;

	  for(int iClu = 0; iClu < nearbyClusters.size(); ++iClu)
	  {
		  float closestDistance = 1.e6;

	  	  auto nearbyCluster = nearbyClusters.at(iClu);

	      try
	      {
	          ClusterHelper::GetClosestDistanceApproach(pCluster, nearbyCluster, closestDistance, m_onlyUseConnectedHits);
	      }
          catch(pandora::StatusCodeException &)
	      {
	          std::cout << "GetClosestDistanceApproach failed" << std::endl;
	      }

		  if(charge == 1)
		  {
			  if(nearbyCluster->GetAssociatedTrackList().size() > 0)
	  	      {
				std::cout << "  near a charged cluster, closestDistance: "  << closestDistance << std::endl;

				unsigned int innerLayer = pCluster->GetInnerPseudoLayer();
				unsigned int outerLayer = pCluster->GetOuterPseudoLayer();

				bool passCheck = true;

				// check hit on the 1st layer
				if(innerLayer==1 && outerLayer < 40) 
				{
	                const pandora::OrderedCaloHitList& orderedCaloHitList = pCluster->GetMainClusterHits();
					auto& hitsAtFirstLayer = *(orderedCaloHitList.begin()->second);

					if(hitsAtFirstLayer.size() > 5) passCheck = false;

					if(passCheck)
					{
						pandora::CaloHitVector seedVec;

					    for(auto& hit : hitsAtFirstLayer)
					    {
					    	const arbor_content::CaloHit *const pArborCaloHit(dynamic_cast<const arbor_content::CaloHit *const>(hit));
							const arbor_content::ConnectorList& backwardConnectorList = 
								ArborContentApi::GetConnectorList(pArborCaloHit, arbor_content::BACKWARD_DIRECTION);
							const arbor_content::ConnectorList& forwardConnectorList = 
								ArborContentApi::GetConnectorList(pArborCaloHit, arbor_content::FORWARD_DIRECTION);

							std::cout << "  hit on 1st layer: " << pArborCaloHit << ", bakConnector: " << backwardConnectorList.size() 
								<< ", fwdConnector: " << forwardConnectorList.size() << std::endl;

							bool isSeed = (backwardConnectorList.size() == 0) && (forwardConnectorList.size() > 0);

					    	if(isSeed) 
					    	{
							    seedVec.push_back(hit);
					    	}

					    }

						float seedsDistance = 0;
						const float maxSeedDistance = 15.; // ECAL cell size 10 mm

						// if cluster has more than one seed on 1st layer, get the maximum seed distance
						if(seedVec.size() > 1)
						{
							for(int iSeed = 0; iSeed < seedVec.size(); ++iSeed)
							{
								for(int jSeed = iSeed + 1; jSeed < seedVec.size(); ++jSeed)
								{
									float distance = 
										(seedVec.at(iSeed)->GetPositionVector() - seedVec.at(jSeed)->GetPositionVector()).GetMagnitude();

									if(seedsDistance < distance)
									{
										seedsDistance = distance;
									}
								}
							}
						}

						if(seedVec.empty() || seedsDistance > maxSeedDistance) 
						{
							std::cout << "     seed size: " << seedVec.size() << ", seedsDistance: " << seedsDistance << std::endl;
							passCheck = false;
						}
					}
				}

				if(passCheck)
				{
					unsigned int nConnectors = ClusterHelper::GetClusterConnectorNumber(pCluster);

					const pandora::OrderedCaloHitList& mainClusterHits = pCluster->GetMainClusterHits();
					pandora::CaloHitList caloHitList;
					mainClusterHits.FillCaloHitList(caloHitList);

					if(caloHitList.size() > 8 && (float)nConnectors/caloHitList.size() < 0.55) 
					{
						passCheck = false;
					    std::cout << "     nConnectors : " << nConnectors << std::endl;
					}
				}

				// TODO::
				// check axes distance, track positon on ECAL (if between two seeds ?)
				 
				if(passCheck) 
				{
					std::cout << "     OK." << std::endl;
				}
				else
				{
					isValidated = false;
				}

				break;
	  	      }
		  }
		  else
		  {
			  if( (nearbyCluster->IsPhoton() || nearbyCluster->GetAssociatedTrackList().size() == 0) &&
				  closestDistance < 50. ) 
		      {
				  //std::cout << "  \033[1;31m near neutral cluster, it maye be a neutral fragment. \033[0m"  << std::endl;

				  break;
		      }
			  else
			  {
				  isValidated = false;
			  }
		  }

	  	  if(closestDistance != 1.e6 && closestDistance > 100.) break;
	  }

	  return isValidated;
  }

  void ChargedFragmentsMergingAlgorithm3::SearchProperClusters(ArborCluster* startingCluster, 
		  std::vector<arbor_content::ArborCluster*>& allClusters,
		  std::vector<arbor_content::ArborCluster*>& properClusters)
  {
	  if(m_debugOutput)
	  {
		  const pandora::Cluster* const pandoraTrackStartClu = dynamic_cast<const pandora::Cluster* const>(startingCluster);
	      float startCluEnergy = startingCluster->GetHadronicEnergy();

	      auto pClusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle(pandoraTrackStartClu);
	      std::cout << " SearchProperClusters for charged cluster: " << startingCluster << ", Ehad: " << startCluEnergy << ", MCP: " << pClusterMCParticle << std::endl;
	  }

	  std::vector<arbor_content::ArborCluster*> nearbyClusters;
	  GetNearbyClusters(startingCluster, allClusters, nearbyClusters);

	  // map for sorting all nearby clusters by closest distance
	  std::multimap<float, ArborCluster*> clusterDistanceMap;

	  for(int i = 0; i < nearbyClusters.size(); ++i)
	  {
		  auto nearbyCluster = nearbyClusters.at(i);

		  if(nearbyCluster == startingCluster || nearbyCluster->IsPhoton()) 
		  {
			  continue;
		  }

		  // GetClustersDistance
		  float closestDistance = 1.e6;

		  try
		  {
			  ClusterHelper::GetClosestDistanceApproach(startingCluster, nearbyCluster, closestDistance, m_onlyUseConnectedHits);
		  }
          catch(pandora::StatusCodeException &)
		  {
			  std::cout << "GetClosestDistanceApproach failed" << std::endl;
		  }

		  bool isMergingCandidate = closestDistance < m_maxClosestClusterDistance;

	      if(m_debugOutput)
		  {
			  std::cout << "  nearbyCluster: " << nearbyCluster << ", E: " << nearbyCluster->GetHadronicEnergy() 
				  << ", closestDistance: " << closestDistance << std::endl;
		  }

		  if(isMergingCandidate) 
		  {
		      clusterDistanceMap.insert( std::pair<float, ArborCluster*>(closestDistance, nearbyCluster) );
		  }
		  else
		  {
	          if(m_debugOutput2) 
			  {
				  std::cout << "    --- Not a merging cadidate" << std::endl;
			  }
		  }

	      if(m_debugOutput2)
		  {
			  std::cout << "-----------------------------------------------------------------------------------------" << std::endl;
		  }
      }
		  
	  for(auto it = clusterDistanceMap.begin(); it != clusterDistanceMap.end(); ++it)
	  {
		  auto nearbyCluster = it->second;
		  properClusters.push_back(nearbyCluster);
	  }

	  if(m_debugOutput)
	  {
		  std::cout << "-----------------------------------------------------------------------------------------------------------" << std::endl;
	  }
  }

  void ChargedFragmentsMergingAlgorithm3::GetNearbyClusters(pandora::Cluster* cluster, 
		  const std::vector<arbor_content::ArborCluster*>& clusterVector, std::vector<arbor_content::ArborCluster*>& clustersInRange)
  {
      pandora::CartesianVector centroid(0., 0., 0.);
	  ClusterHelper::GetCentroid(cluster, centroid);

	  const float distance = m_maxStartingClusterDistance;
	  const mlpack::math::Range range(0., distance);

      arma::mat testPoint(3, 1);
	  testPoint.col(0)[0] = centroid.GetX();
	  testPoint.col(0)[1] = centroid.GetY();
	  testPoint.col(0)[2] = centroid.GetZ();
	  
	  if(m_clusterCentroidsMatrix.size() == 0) 
	  {
		  std::cout << " Error: clusterCentroidsMatrix is null. " << std::endl;
		  return;
	  }

	  mlpack::range::RangeSearch<> rangeSearch(m_clusterCentroidsMatrix);
      std::vector<std::vector<size_t> > resultingNeighbors;
      std::vector<std::vector<double> > resultingDistances;
      rangeSearch.Search(testPoint, range, resultingNeighbors, resultingDistances);

      std::vector<size_t>& neighbors = resultingNeighbors.at(0);
      std::vector<double>& distances = resultingDistances.at(0);
	  
      for(size_t j=0; j < neighbors.size(); ++j)
      {
      	size_t neighbor = neighbors.at(j);
      	//double hitsDist = distances.at(j);

		clustersInRange.push_back( clusterVector.at(neighbor) );
	  }


	  // sort cluster by distance
	  std::multimap<float, ArborCluster*> clusterDistanceMap;

	  for(int i = 0; i < clustersInRange.size(); ++i)
	  {
		  auto clusterInRange = clustersInRange.at(i);

		  clusterDistanceMap.insert( std::pair<float, ArborCluster*>(distances.at(i), clusterInRange) );
	  }

	  clustersInRange.clear();

	  for(auto& mapIter : clusterDistanceMap)
	  {
		  auto clu = mapIter.second;
		  clustersInRange.push_back(clu);
	  }
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ChargedFragmentsMergingAlgorithm3::GetEligibleClusters(std::vector<ArborCluster*>& clusterVector) const
  {
	clusterVector.clear();

    const pandora::ClusterList *pClusterList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

	//std::cout << ">>>cluster number: " << pClusterList->size() << std::endl;

    if(pClusterList->empty())
      return pandora::STATUS_CODE_SUCCESS;

    for(pandora::ClusterList::const_iterator clusterIter = pClusterList->begin(), clusterEndIter = pClusterList->end() ;
        clusterEndIter != clusterIter ; ++clusterIter)
    {
      const pandora::Cluster *const pCluster = *clusterIter;

      //if(!this->CanMergeCluster(pCluster))
      //  continue;

	  auto arborCluster = ArborContentApi::Modifiable(dynamic_cast<const arbor_content::ArborCluster*>(pCluster));
      clusterVector.push_back(arborCluster);
    }

	std::sort(clusterVector.begin(), clusterVector.end(), pandora_monitoring::PandoraMonitoring::SortClustersByHadronicEnergy);

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ChargedFragmentsMergingAlgorithm3::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    m_maxStartingClusterDistance = 1000.;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxStartingClusterDistance", m_maxStartingClusterDistance));

	m_maxClosestClusterDistance = 300.;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxClosestClusterDistance", m_maxClosestClusterDistance));

	m_debugOutput = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "DebugOutput", m_debugOutput));

	m_debugOutput2 = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "DebugOutput2", m_debugOutput2));

	m_onlyUseConnectedHits = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "OnlyUseConnectedHits", m_onlyUseConnectedHits));

	m_useMCPForPID = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "UseMCPForPID", m_useMCPForPID));

	m_makeRecord = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MakeRecord", m_makeRecord));

    return pandora::STATUS_CODE_SUCCESS;
  }

} 


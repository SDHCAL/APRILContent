/// \file ClusterHelper.cc
/*
 *
 * ClusterHelper.cc source template automatically generated by a class generator
 * Creation date : ven. avr. 10 2015
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#include "Pandora/AlgorithmHeaders.h"

#include "ArborHelpers/ClusterHelper.h"
#include "ArborHelpers/CaloHitHelper.h"
#include "ArborHelpers/GeometryHelper.h"
#include "ArborHelpers/ReclusterHelper.h"

#include "TMatrixT.h"
#include "TMatrixDEigen.h"
#include "TVectorD.h"

namespace arbor_content
{

  ClusterPca::Component::Component() :
      m_eigenValue(0.f),
      m_eigenVector(0.f, 0.f, 0.f)
  {
    /* nop */
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  ClusterPca::ClusterPca(const pandora::Cluster *const pCluster) :
		    m_pCluster(pCluster)
  {
    if(NULL == pCluster || 2 > pCluster->GetNCaloHits())
      throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);

    float mean[3] = {0.f};

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    const unsigned nDofs(clusterCaloHitList.size());

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin() , endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);

      mean[0] += pCaloHit->GetPositionVector().GetX();
      mean[1] += pCaloHit->GetPositionVector().GetY();
      mean[2] += pCaloHit->GetPositionVector().GetZ();
    }

    mean[0] /= nDofs;
    mean[1] /= nDofs;
    mean[2] /= nDofs;

    TMatrixD covarianceMatrix(3, 3);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin() , endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);

      float x(pCaloHit->GetPositionVector().GetX() - mean[0]);
      float y(pCaloHit->GetPositionVector().GetY() - mean[1]);
      float z(pCaloHit->GetPositionVector().GetZ() - mean[2]);

      covarianceMatrix(0, 0) += ((x*x) / nDofs);
      covarianceMatrix(1, 1) += ((y*y) / nDofs);
      covarianceMatrix(2, 2) += ((z*z) / nDofs);

      covarianceMatrix(0, 1) += ((x*y) / nDofs);
      covarianceMatrix(0, 2) += ((x*z) / nDofs);
      covarianceMatrix(1, 2) += ((y*z) / nDofs);
    }

    covarianceMatrix(1, 0) = covarianceMatrix(0, 1);
    covarianceMatrix(2, 0) = covarianceMatrix(0, 2);
    covarianceMatrix(2, 1) = covarianceMatrix(1, 2);

    TMatrixDEigen eigenMatrix(covarianceMatrix);

    for(unsigned int i=0 ; i<3 ; i++)
    {
      m_components[i].m_eigenValue = eigenMatrix.GetEigenValuesRe()[i];

      const float x(eigenMatrix.GetEigenVectors()[i][0]);
      const float y(eigenMatrix.GetEigenVectors()[i][1]);
      const float z(eigenMatrix.GetEigenVectors()[i][2]);

      m_components[i].m_eigenVector.SetValues(x, y, z);

      //		std::cout << "Eigen val [" << i << "] : val = " << m_components[i].m_eigenValue << " , vec = " << m_components[i].m_eigenVector << std::endl;
    }

    m_transverseRatio = std::sqrt(m_components[2].m_eigenValue*m_components[2].m_eigenValue + m_components[1].m_eigenValue*m_components[1].m_eigenValue) / m_components[0].m_eigenValue;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetCentroid(const pandora::Cluster *const pCluster, pandora::CartesianVector &centroid)
  {
    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());

    for(pandora::OrderedCaloHitList::const_iterator iter = orderedCaloHitList.begin(), endIter = orderedCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      centroid += pCluster->GetCentroid(iter->first);
    }

    centroid *= 1.f/(orderedCaloHitList.size());

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetClosestDistanceApproach(const pandora::Cluster *const pCluster, const pandora::CartesianVector &point,
      float &closestDistance)
  {
    closestDistance = std::numeric_limits<float>::max();

    if(NULL == pCluster)
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    if(0 == pCluster->GetNCaloHits())
      return pandora::STATUS_CODE_FAILURE;

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin() , endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit = *iter;
      const float distance = (pCaloHit->GetPositionVector() - point).GetMagnitude();

      if(closestDistance > distance)
        closestDistance = distance;
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetCentroidDistance(const pandora::Cluster *const pCluster, const pandora::CartesianVector &point,
      float &centroidDistance)
  {
    centroidDistance = std::numeric_limits<float>::max();

    if(NULL == pCluster)
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    if(0 == pCluster->GetNCaloHits())
      return pandora::STATUS_CODE_FAILURE;

    pandora::CartesianVector clusterCentroid(0.f, 0.f, 0.f);
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCentroid(pCluster, clusterCentroid));

    centroidDistance = (clusterCentroid - point).GetMagnitude();

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetClosestDistanceApproach(const pandora::Cluster *const pCluster1, const pandora::Cluster *const pCluster2,
      float &closestDistance)
  {
    closestDistance = std::numeric_limits<float>::max();

    if(NULL == pCluster1 || NULL == pCluster2)
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    if(0 == pCluster1->GetNCaloHits() || 0 == pCluster2->GetNCaloHits())
      return pandora::STATUS_CODE_FAILURE;

    pandora::CaloHitList clusterCaloHitList1;
    pCluster1->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList1);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList1.begin() , endIter = clusterCaloHitList1.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit = *iter;
      float closestHitDistanceApproach(std::numeric_limits<float>::max());

      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetClosestDistanceApproach(pCluster2,
          pCaloHit->GetPositionVector(), closestHitDistanceApproach));

      if(closestHitDistanceApproach < closestDistance)
        closestDistance = closestHitDistanceApproach;
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetNCaloHitSeeds(const pandora::Cluster *const pCluster, unsigned int &nSeeds)
  {
    if(NULL == pCluster)
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    pandora::CaloHitList clusterCaloHitList;
    pandora::CaloHitList seedsCaloHitList;

    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::ExtractSeedCaloHitList(&clusterCaloHitList, seedsCaloHitList));

    nSeeds = seedsCaloHitList.size();

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool ClusterHelper::IsClusterLeavingDetector(const pandora::Pandora &pandora, const pandora::Cluster *const pCluster, unsigned int nOuterLayersToExamine,
      float maxDistanceToDetectorEdge, unsigned int minNHitsNearEdges)
  {
    if(NULL == pCluster)
      throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);

    // muons escape detector
    if( abs(pCluster->GetParticleId()) == 13 || ClusterHelper::ContainsHitType(pCluster, pandora::MUON))
      return true;

    if(pandora::HCAL != pCluster->GetOuterLayerHitType())
      return false;

    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());
    const unsigned int outerPseudoLayer(pCluster->GetOuterPseudoLayer());
    const unsigned int innerPseudoLayer(pCluster->GetInnerPseudoLayer());
    const unsigned int nPseudoLayers(outerPseudoLayer-innerPseudoLayer+1);
    const unsigned int pseudoLayerStart(nPseudoLayers < nOuterLayersToExamine ? innerPseudoLayer : outerPseudoLayer-nOuterLayersToExamine);

    const pandora::GeometryManager *const pGeometry = pandora.GetGeometry();

    const pandora::SubDetector &hcalEndcap(pGeometry->GetSubDetector(pandora::HCAL_ENDCAP));
    const pandora::SubDetector &hcalBarrel(pGeometry->GetSubDetector(pandora::HCAL_BARREL));

    const float hcalEndcapOuterZCoordinate(hcalEndcap.GetOuterZCoordinate());
    const float hcalEndcapOuterRCoordinate(hcalEndcap.GetOuterRCoordinate());
    const float hcalBarrelOuterRCoordinate(hcalBarrel.GetOuterRCoordinate());

    unsigned int nHitsNearbyEdge(0);

    for(unsigned int pl=pseudoLayerStart ; pl<outerPseudoLayer ; ++pl)
    {
      pandora::OrderedCaloHitList::const_iterator iter = orderedCaloHitList.find(pl);

      if(orderedCaloHitList.end() == iter)
        continue;

      for (pandora::CaloHitList::const_iterator hitIter = iter->second->begin(), hitIterEnd = iter->second->end() ;
          hitIter != hitIterEnd; ++hitIter)
      {
        const pandora::CaloHit *const pCaloHit(*hitIter);

        if(pandora::HCAL != pCaloHit->GetHitType())
          continue;

        if(pandora::ENDCAP == pCaloHit->GetHitRegion())
        {
          pandora::CartesianVector outerNormaleVector(0.f, 0.f, 0.f);

          if(pandora::STATUS_CODE_SUCCESS != GeometryHelper::GetOuterNormaleVector(pandora, pandora::HCAL_ENDCAP, (*hitIter)->GetPositionVector(), outerNormaleVector))
            continue;

          const float hitCosAngleNormale(outerNormaleVector.GetCosOpeningAngle(pCaloHit->GetPositionVector()));
          const float hitDistanceToOrigin(pCaloHit->GetPositionVector().GetMagnitude());
          const float hitDistanceToREdge(hcalEndcapOuterRCoordinate - hitDistanceToOrigin*hitCosAngleNormale);
          const float hitDistanceToZEdge(hcalEndcapOuterZCoordinate-fabs(pCaloHit->GetPositionVector().GetZ()));

          if(hitDistanceToREdge < maxDistanceToDetectorEdge)
            ++nHitsNearbyEdge;
          else if(hitDistanceToZEdge < maxDistanceToDetectorEdge)
            ++nHitsNearbyEdge;
        }
        else if(pandora::BARREL == pCaloHit->GetHitRegion())
        {
          pandora::CartesianVector outerNormaleVector(0.f, 0.f, 0.f);

          if(pandora::STATUS_CODE_SUCCESS != GeometryHelper::GetOuterNormaleVector(pandora, pandora::HCAL_BARREL, (*hitIter)->GetPositionVector(), outerNormaleVector))
            continue;

          const float hitCosAngleNormale(outerNormaleVector.GetCosOpeningAngle(pCaloHit->GetPositionVector()));
          const float hitDistanceToOrigin(pCaloHit->GetPositionVector().GetMagnitude());
          const float hitDistanceToEdge(hcalBarrelOuterRCoordinate - hitDistanceToOrigin*hitCosAngleNormale);

          if(hitDistanceToEdge < maxDistanceToDetectorEdge)
            ++nHitsNearbyEdge;
        }
      }
    }

    if(nHitsNearbyEdge >= minNHitsNearEdges)
      return true;

    return false;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool ClusterHelper::ContainsHitType(const pandora::Cluster *const pCluster, const pandora::HitType hitType)
  {
    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());

    for (pandora::OrderedCaloHitList::const_reverse_iterator iter = orderedCaloHitList.rbegin(), iterEnd = orderedCaloHitList.rend(); iter != iterEnd; ++iter)
    {
      for (pandora::CaloHitList::const_iterator hIter = iter->second->begin(), hIterEnd = iter->second->end(); hIter != hIterEnd; ++hIter)
      {
        const pandora::CaloHit *const pCaloHit(*hIter);

        if (hitType == pCaloHit->GetHitType())
          return true;
      }
    }

    return false;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetMeanSurroundingEnergy(const pandora::Cluster *const pCluster, float &meanSurroundingEnergy)
  {
    if(NULL == pCluster || 0 == pCluster->GetNCaloHits())
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    meanSurroundingEnergy = 0.f;

    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());

    for (pandora::OrderedCaloHitList::const_reverse_iterator iter = orderedCaloHitList.rbegin(), iterEnd = orderedCaloHitList.rend(); iter != iterEnd; ++iter)
    {
      for (pandora::CaloHitList::const_iterator hIter = iter->second->begin(), hIterEnd = iter->second->end(); hIter != hIterEnd; ++hIter)
      {
        const arbor_content::CaloHit *const pCaloHit(dynamic_cast<const arbor_content::CaloHit *const>(*hIter));

        if(NULL == pCaloHit)
          return pandora::STATUS_CODE_INVALID_PARAMETER;

        meanSurroundingEnergy += pCaloHit->GetSurroundingEnergy();
      }
    }

    meanSurroundingEnergy /= pCluster->GetNCaloHits();

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetMeanDensity(const pandora::Cluster *const pCluster, float &meanDensity)
  {
    if(NULL == pCluster || 0 == pCluster->GetNCaloHits())
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    meanDensity = 0.f;

    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());

    for (pandora::OrderedCaloHitList::const_reverse_iterator iter = orderedCaloHitList.rbegin(), iterEnd = orderedCaloHitList.rend(); iter != iterEnd; ++iter)
    {
      for (pandora::CaloHitList::const_iterator hIter = iter->second->begin(), hIterEnd = iter->second->end(); hIter != hIterEnd; ++hIter)
      {
        const arbor_content::CaloHit *const pCaloHit(dynamic_cast<const arbor_content::CaloHit *const>(*hIter));

        if(NULL == pCaloHit)
          return pandora::STATUS_CODE_INVALID_PARAMETER;

        meanDensity += pCaloHit->GetDensity();
      }
    }

    meanDensity /= pCluster->GetNCaloHits();

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetChiClusterMerging(const pandora::Pandora &pandora, const pandora::Cluster *const pClusterToEnlarge, const pandora::Cluster *const pClusterToMerge, float &oldChi, float &newChi)
  {
    const pandora::TrackList trackList(pClusterToEnlarge->GetAssociatedTrackList());

    pandora::TrackList trackListCombined(pClusterToMerge->GetAssociatedTrackList());
    trackListCombined.insert(trackListCombined.begin(), trackList.begin(), trackList.end());

    if(trackList.empty())
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    float trackEnergySum(0.f);
    float trackEnergySumCombined(0.f);

    for (pandora::TrackList::const_iterator trackIter = trackList.begin(), trackIterEnd = trackList.end(); trackIter != trackIterEnd; ++trackIter)
      trackEnergySum += (*trackIter)->GetEnergyAtDca();

    for (pandora::TrackList::const_iterator trackIter = trackListCombined.begin(), trackIterEnd = trackListCombined.end(); trackIter != trackIterEnd; ++trackIter)
      trackEnergySumCombined += (*trackIter)->GetEnergyAtDca();

    const float clusterEnergy(pClusterToEnlarge->GetTrackComparisonEnergy(pandora));
    const float clusterEnergyCombined(clusterEnergy + pClusterToMerge->GetTrackComparisonEnergy(pandora));

    oldChi = ReclusterHelper::GetTrackClusterCompatibility(pandora, clusterEnergy, trackEnergySum);
    newChi = ReclusterHelper::GetTrackClusterCompatibility(pandora, clusterEnergyCombined, trackEnergySumCombined);

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::MergeClusters(const pandora::Algorithm &algorithm, ClusterToClusterMap &clusterToClusterMap)
  {
    for(ClusterToClusterMap::iterator iter = clusterToClusterMap.begin(), endIter = clusterToClusterMap.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::Cluster *const pDaughterCluster(iter->first);
      const pandora::Cluster *const pParentCluster(iter->second);

      if((NULL == pDaughterCluster) || (NULL == pParentCluster))
        continue;

      for(ClusterToClusterMap::iterator jter = clusterToClusterMap.begin(), endJter = clusterToClusterMap.end() ;
          endJter != jter ; ++jter)
      {
        if(jter->first == pDaughterCluster)
          continue;

        if(jter->second == pDaughterCluster)
          jter->second = pParentCluster;
      }

      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::MergeAndDeleteClusters(algorithm, pParentCluster, pDaughterCluster));

      (iter->second) = NULL;
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetTrackClusterDistance(const pandora::Pandora &pandora, const pandora::Cluster *const pCluster, const pandora::Track *const pTrack, const float maxTransverseDistance, float &trackClusterDistance)
  {
    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    const float bField(pandora.GetPlugins()->GetBFieldPlugin()->GetBField(pandora::CartesianVector(0.f, 0.f, 0.f)));
    const pandora::Helix helix(pTrack->GetTrackStateAtCalorimeter().GetPosition(),
        pTrack->GetTrackStateAtCalorimeter().GetMomentum(), pTrack->GetCharge(), bField);

    const pandora::CartesianVector trackProjection(pTrack->GetTrackStateAtCalorimeter().GetPosition());

    unsigned int nNearbyCaloHits(0);
    float distanceToHelix(0.f);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin() , endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);

      const float trackHitAngle(pCaloHit->GetPositionVector().GetOpeningAngle(trackProjection));

      // cut needed for discriminate track opposite direction
      if(trackHitAngle > (2*M_PI)/3.f)
        continue;

      pandora::CartesianVector projectionOnHelix(0.f, 0.f, 0.f);
      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, GeometryHelper::GetProjectionOnHelix(helix, pCaloHit->GetPositionVector(), projectionOnHelix));
      const float hitDistanceToHelix((pCaloHit->GetPositionVector()-projectionOnHelix).GetMagnitude());

      if(hitDistanceToHelix < maxTransverseDistance)
      {
        ++nNearbyCaloHits;
        distanceToHelix += hitDistanceToHelix;
      }
    }

    if(0 == nNearbyCaloHits)
      return pandora::STATUS_CODE_NOT_FOUND;

    trackClusterDistance = distanceToHelix / nNearbyCaloHits;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool ClusterHelper::DoesClusterCrossGapRegion(const pandora::Pandora &pandora, const pandora::Cluster *const pCluster, const unsigned int startLayer,
      const unsigned int endLayer, const pandora::DetectorGap *&pDetectorGap, const unsigned int nSamplingPoints)
  {
    const unsigned int fitStartLayer(std::max(startLayer, pCluster->GetInnerPseudoLayer()));
    const unsigned int fitEndLayer(std::min(endLayer, pCluster->GetOuterPseudoLayer()));

    if (fitStartLayer > fitEndLayer)
      throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);

    pandora::ClusterFitResult fitResult;
    if (pandora::STATUS_CODE_SUCCESS != pandora::ClusterFitHelper::FitLayers(pCluster, fitStartLayer, fitEndLayer, fitResult))
      return false;

    const pandora::CartesianVector startLayerCentroid(pCluster->GetCentroid(fitStartLayer));
    const float propagationDistance((pCluster->GetCentroid(fitEndLayer) - startLayerCentroid).GetDotProduct(fitResult.GetDirection()));

    return ClusterHelper::DoesFitCrossGapRegion(pandora, fitResult, startLayerCentroid, propagationDistance, pDetectorGap, nSamplingPoints);
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool ClusterHelper::DoesFitCrossGapRegion(const pandora::Pandora &pandora, const pandora::ClusterFitResult &clusterFitResult,
      const pandora::CartesianVector &startPosition, const float propagationDistance, const pandora::DetectorGap *&pDetectorGap, const unsigned int nSamplingPoints)
  {
    const pandora::CartesianVector &fitDirection(clusterFitResult.GetDirection());
    const pandora::CartesianVector &fitIntercept(clusterFitResult.GetIntercept());

    const float fitStartDistance((startPosition - fitIntercept).GetDotProduct(fitDirection));
    const pandora::CartesianVector fitStartPosition(fitIntercept + (fitDirection * fitStartDistance));
    const pandora::CartesianVector fitPropagation(fitDirection * propagationDistance);

    const pandora::DetectorGapList &detectorGapList(pandora.GetGeometry()->GetDetectorGapList());

    for (unsigned int i = 0; i < nSamplingPoints; ++i)
    {
      const pandora::CartesianVector fitPosition(fitStartPosition + (fitPropagation * (static_cast<float>(i) / static_cast<float>(nSamplingPoints))));

      for (pandora::DetectorGapList::const_iterator iter = detectorGapList.begin(), iterEnd = detectorGapList.end(); iter != iterEnd; ++iter)
      {
        // ATTN Could pass (e.g. inner layer) hit type for cluster, but know that actually need to pass only any 3D hit type (hack)
        if ((*iter)->IsInGap(fitPosition, pandora::ECAL))
        {
          pDetectorGap = *iter;
          return true;
        }
      }
    }

    return false;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetDistanceToDetectorGap(const pandora::CartesianVector &positionVector, const pandora::DetectorGap *const pDetectorGap, float &distanceToGap)
  {
    distanceToGap = 0.f;

    if(NULL == pDetectorGap)
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    if(pDetectorGap->IsInGap(positionVector, pandora::ECAL))
      return pandora::STATUS_CODE_FAILURE;

    const pandora::BoxGap *const pBoxGap(dynamic_cast<const pandora::BoxGap *const>(pDetectorGap));

    if(pBoxGap)
    {
      const pandora::CartesianVector relativePosition(positionVector - pBoxGap->GetVertex());

      const float projection1(relativePosition.GetDotProduct(pBoxGap->GetSide1().GetUnitVector()));
      const float projection2(relativePosition.GetDotProduct(pBoxGap->GetSide2().GetUnitVector()));
      const float projection3(relativePosition.GetDotProduct(pBoxGap->GetSide3().GetUnitVector()));

      distanceToGap = std::min(fabs(projection1), std::min(fabs(projection2), fabs(projection3)));

      return pandora::STATUS_CODE_SUCCESS;
    }

    const pandora::ConcentricGap *const pConcentricGap(dynamic_cast<const pandora::ConcentricGap *const>(pDetectorGap));

    if(pConcentricGap)
    {
      const float z(positionVector.GetZ());
      const float x(positionVector.GetX()), y(positionVector.GetY());
      const float r(std::sqrt(x * x + y * y));
      bool inner(false), outer(false);
      const bool inZ(pConcentricGap->GetMaxZCoordinate() < z && pConcentricGap->GetMinZCoordinate() > z);
      float zDistance(0.f), rInnerDistance(0.f), rOuterDistance(0.f);

      if(pConcentricGap->GetMaxZCoordinate() < z)
      {
        zDistance = fabs(z - pConcentricGap->GetMaxZCoordinate());
      }

      if(pConcentricGap->GetMinZCoordinate() > z)
      {
        zDistance = fabs(z - pConcentricGap->GetMinZCoordinate());
      }

      // inner r case
      for(unsigned int i=0 ; i<pConcentricGap->GetInnerSymmetryOrder()+1 ; i++)
      {
        const float phi = pConcentricGap->GetInnerPhiCoordinate() + 2 * M_PI * (static_cast<float>(i) / static_cast<float>(pConcentricGap->GetInnerSymmetryOrder()));
        const float phiMin = phi - (2 * M_PI / static_cast<float>(pConcentricGap->GetInnerSymmetryOrder())) / 2.f;
        const float phiMax = phi + (2 * M_PI / static_cast<float>(pConcentricGap->GetInnerSymmetryOrder())) / 2.f;
        const float phiPosition(std::atan2(y, x));

        if(phiPosition > phiMin && phiPosition < phiMax)
        {
          const pandora::CartesianVector normaleVector(std::cos(phi), std::sin(phi), 0.f);

          if(r*std::cos(normaleVector.GetOpeningAngle(positionVector)) < pConcentricGap->GetInnerRCoordinate())
          {
            rInnerDistance = fabs(pConcentricGap->GetInnerRCoordinate() - r*std::cos(normaleVector.GetOpeningAngle(positionVector)));
            inner = true;
          }

          break;
        }
      }

      // outer r case
      for(unsigned int i=0 ; i<pConcentricGap->GetOuterSymmetryOrder()+1 ; i++)
      {
        const float phi = pConcentricGap->GetOuterPhiCoordinate() + 2 * M_PI * (static_cast<float>(i) / static_cast<float>(pConcentricGap->GetOuterSymmetryOrder()));
        const float phiMin = phi - (2 * M_PI / static_cast<float>(pConcentricGap->GetOuterSymmetryOrder())) / 2.f;
        const float phiMax = phi + (2 * M_PI / static_cast<float>(pConcentricGap->GetOuterSymmetryOrder())) / 2.f;
        const float phiPosition(std::atan2(y, x));

        if(phiPosition > phiMin && phiPosition < phiMax)
        {
          const pandora::CartesianVector normaleVector(std::cos(phi), std::sin(phi), 0.f);

          if(r*std::cos(normaleVector.GetOpeningAngle(positionVector)) > pConcentricGap->GetOuterRCoordinate())
          {
            rOuterDistance = fabs(r*std::cos(normaleVector.GetOpeningAngle(positionVector)) - pConcentricGap->GetOuterRCoordinate());
            outer = true;
          }

          break;
        }
      }

      if(!inner && !outer)
      {
        distanceToGap = fabs(zDistance);
      }
      else if(inZ)
      {
        if(inner)
          distanceToGap = fabs(rInnerDistance);
        else
          distanceToGap = fabs(rOuterDistance);
      }
      else
      {
        float rDistance(inner ? rInnerDistance : rOuterDistance);
        distanceToGap = std::sqrt(fabs(rDistance)*fabs(rDistance) + fabs(zDistance)*fabs(zDistance));
      }

      return pandora::STATUS_CODE_SUCCESS;
    }

    return pandora::STATUS_CODE_FAILURE;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetCaloHitsNearDetectorGaps(const pandora::Pandora &pandora, const pandora::Cluster *const pCluster, const float maxDistanceFine,
      const float maxDistanceCoarse, pandora::CaloHitList &caloHitList, bool shouldUseIsolatedHits)
  {
    const pandora::DetectorGapList &detectorGapList(pandora.GetGeometry()->GetDetectorGapList());

    for (pandora::DetectorGapList::const_iterator iter = detectorGapList.begin(), iterEnd = detectorGapList.end(); iter != iterEnd; ++iter)
    {
      const pandora::DetectorGap *const pDetectorGap(*iter);
      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCaloHitsNearDetectorGap(pandora, pCluster, pDetectorGap, maxDistanceFine, maxDistanceCoarse, caloHitList, shouldUseIsolatedHits));
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetCaloHitsNearDetectorGap(const pandora::Pandora &pandora, const pandora::Cluster *const pCluster, const pandora::DetectorGap *const pDetectorGap,
      const float maxDistanceFine, const float maxDistanceCoarse, pandora::CaloHitList &caloHitList, bool shouldUseIsolatedHits)
  {
    if(0 == pCluster->GetNCaloHits())
      return pandora::STATUS_CODE_SUCCESS;

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin() , endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);

      if(!shouldUseIsolatedHits && pCaloHit->IsIsolated())
        continue;

      const pandora::Granularity &granularity(pandora.GetGeometry()->GetHitTypeGranularity(pCaloHit->GetHitType()));
      const float maxDistance(granularity <= pandora::FINE ? maxDistanceFine : maxDistanceCoarse);
      float distanceToGap(0.f);

      if(pandora::STATUS_CODE_SUCCESS != ClusterHelper::GetDistanceToDetectorGap(pCaloHit->GetPositionVector(), pDetectorGap, distanceToGap))
        continue;

      if(distanceToGap < maxDistance)
        caloHitList.push_back(pCaloHit);
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::CleanAndDeleteCluster(const pandora::Algorithm &algorithm, const pandora::Cluster *const pCluster)
  {
    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin() , endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const arbor_content::CaloHit *const pCaloHit(dynamic_cast<const arbor_content::CaloHit *const>(*iter));

      if(NULL == pCaloHit)
        continue;

      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::RemoveAndDeleteAllConnections(pCaloHit));
    }

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Delete(algorithm, pCluster));

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::CleanAndDeleteClusters(const pandora::Algorithm &algorithm, const pandora::ClusterList &clusterList)
  {
    for(pandora::ClusterList::const_iterator iter = clusterList.begin(), endIter = clusterList.end() ;
        endIter != iter ; ++iter)
    {
      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::CleanAndDeleteCluster(algorithm, *iter));
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

} 

